import argparse
import math

OMSP_SYSTEM_METADATA = "#define SPECCFA_METADATA_BASE_ADDR      0x0400"
OMSP_SYSTEM_APP = "// For validating spec-cfa correctness\n#define APPS 0"
OMSP_SYSTEM_TEST_APP = "#define TEST_APP APPS"

def parse_args():
    """
    Builds an argument parser to get command line input
    Returns: 
        The parsed arguements
    """
    parser = argparse.ArgumentParser()
    
    parser.add_argument("-f", "--file", type=str, required=True, help="A file containing the selected subpaths")
    parser.add_argument("-s", "--size", type=int, default=256, help="The size of each log slice in bytes")
    parser.add_argument("-a", "--app", type=str, choices=["geiger", "gps", 'syringe', "temperature", "ultrasonic", "poly", "quick", "mouse", "sudoku"], required=True, help="The app being tested")
    
    subparsers = parser.add_subparsers(help="The subpath file type/generation method", dest="type", required=True)
    subparsers.add_parser("manual", help="Subpath file was generated using manual inspection")
    subparsers.add_parser("log", help="Subpath file was generated by analysing prior logs (path_selection.py)")
    subparsers.add_parser("binary", help="Subpath file was generated using binary analysis")

    return parser.parse_args()


def get_subpaths_manual(subpath_file):
    """
    Opens the supplied path_selection output file and grabs the subpaths from it
    Args:
        subpath_file (str): The path to the file containing the sub path selection
    Returns:
        A List of the parsed subpaths
    """
    subpaths = ""
    with open(subpath_file, "r") as fp:
        subpaths = fp.readlines()
    

    for i in range(len(subpaths)):
        subpath = subpaths[i].strip()
        subpaths[i] = subpath.split()

    return subpaths


def get_subpaths_log(subpath_file):
    """
    Opens the supplied path_selection output file and grabs the subpaths from it
    Args:
        subpath_file (str): The path to the file containing the sub path selection
    Returns:
        A List of the parsed subpaths
    """
    whole_log = ""
    with open(subpath_file, "r") as fp:
        whole_log = fp.readlines()
    subpaths = whole_log[2:-2]  # Cut useless line. Will need editing for more generic uses
    

    for i in range(len(subpaths)):
        tokens = subpaths[i].split("-")
        subpath = tokens[-1].strip()
        subpaths[i] = subpath.split()

    return subpaths


def build_test_strings(subpaths, app):
    """
    Generates omsp_system.h, validate.py, and wrapper.c bodies for the selected subpaths
    Args:
        subpaths (list(str)): A list representation of the selected subpaths
        app (str): The name of the application being optimize
    Returns:
        Strings for the body of the omsp_system.h, validate.py, and wrapper.c files for the supplied paths
    """

    # Initializing strings
    validate_string = ""
    wrapper_string = ""
    system_string = OMSP_SYSTEM_METADATA[:] + "\n\n"
    system_string += OMSP_SYSTEM_APP[:].replace("APPS", (app + (" " * (15 - len(app))))) +"\n"
    system_string += OMSP_SYSTEM_TEST_APP[:].replace("APPS", ((" " * 7) + app)) +"\n\n"
    
    # Build the path information for each file
    path_count = 1
    for subpath in subpaths:
        
        # Add the initial line for each subpath in wrapper.c
        if path_count == 1:
            wrapper_string += f"// BLOCK 1\n\t*((uint16_t *)(BLOCK1_ADDR)) = (BLOCK1_ID << 8) | BLOCK1_LEN;\n\t"
        else:
            wrapper_string += f"\t// BLOCK {path_count}\n\t*((uint16_t *)(BLOCK{path_count}_ADDR)) = (BLOCK{path_count}_ID << 8) | BLOCK{path_count}_LEN;\n\t"

        # Generate the subpath ID for validate.py
        temp_validate_id = hex(path_count)[2:]
        validate_string += f"subpaths['1111{'0' * (4 - len(temp_validate_id))}{temp_validate_id}'] = {subpath}\n"

        # Add the memory address of each path in memory
        if path_count == 1:
            system_string += f"// Block 1 Data\n#define BLOCK1_ADDR     SPECCFA_METADATA_BASE_ADDR\n"
        else:
            system_string += f"// Block {path_count} Data\n#define BLOCK{path_count}_ADDR     BLOCK{path_count - 1}_ADDR + 2 + BLOCK{path_count - 1}_LEN*4 // 4 bytes per transition\n"
        system_string += f"#define BLOCK{path_count}_ID       {path_count}\n#define BLOCK{path_count}_LEN      {len(subpath)}\n"

        # Loop over each entry in each subpath to add the appropriate entries
        for i in range(len(subpath)):
            wrapper_string += f"*((uint16_t *)(BLOCK{path_count}_ADDR+{(i*4) + 2})) = BLOCK{path_count}_SRC{i+1};\n\t*((uint16_t *)(BLOCK{path_count}_ADDR+{(i*4)+4})) = BLOCK{path_count}_DEST{i+1};\n\t"

            system_string += f"#define BLOCK{path_count}_SRC{i+1}     0x{subpath[i][:4]}\n#define BLOCK{path_count}_DEST{i+1}    0x{subpath[i][4:]}\n"
        
        # Housekeeping
        wrapper_string += "\n"
        system_string += "\n"
        path_count += 1

    # Add the final metadata info to system.h    
    system_string += f"// Metadata Values\n#define SPECCFA_TOTAL_BLOCKS            {path_count-1}\n#define SPECCFA_BLOCK_MIN               BLOCK1_ADDR\n#define SPECCFA_BLOCK_MAX               BLOCK{path_count-1}_ADDR + 2 + BLOCK{path_count-1}_LEN*4\n"
    return system_string, validate_string, wrapper_string
        

def build_test_files(subpaths, app, size):
    """
    Generates the omsp_system.h, validate.py, and wrapper.c file
    Args:
        subpaths (list(str)): A list representation of the selected subpaths
        app (str): The name of the application being optimize
        size (int): The size of each log slice in bytes
    Returns:
        None
    """
    system, validate, wrapper = build_test_strings(subpaths, app)

    # Update templates and write to files
    sys_template = ""
    with open("templates/omsp_system.h", "r") as sys_file:
        sys_template = sys_file.read()
    sys_template = sys_template.replace("SUBPATHS", system)
    with open("../tcb/omsp_system.h", "w") as sys_file:
        sys_file.write(sys_template)

    val_template = ""
    with open("templates/validate.py", "r") as val_file:
        val_template = val_file.read()
    val_template = val_template.replace("BASELINE", app.lower())
    val_template = val_template.replace("SUBPATHS", validate)
    with open("../inspector/validate.py", "w") as val_file:
        val_file.write(val_template)

    wrap_template = ""
    with open("templates/wrapper.c", "r") as wrap_file:
        wrap_template = wrap_file.read()
    wrap_template = wrap_template.replace("BITS", str(size))
    wrap_template = wrap_template.replace("SUBPATHS", wrapper)
    with open("../tcb/wrapper.c", "w") as wrap_file:
        wrap_file.write(wrap_template)
    

def build_blockmem(paths):
    """
    Builds the blockmem.v file for the selected paths
    Args:
        paths (int): The number of selected paths
    Returns:
        None
    """
    # Initialize our strings
    outputs = ""
    inputs = ""
    output_declarations = ""
    input_declarations = ""
    registers = ""
    assigns = ""
    bases = ""

    # Add the appropriate hardware for each subpath in the test
    for i in range(1, paths+1):
        if i == 1:
            outputs += "block_entry_src,\n\tblock_entry_dest,\n\tblock_len,\n\tblock_id,\n\t"
            inputs += "block_ptr,\n\t"
            output_declarations += "output [15:0] block_entry_src;\noutput [15:0] block_entry_dest;\noutput [7:0] block_len;\noutput [7:0] block_id;\n"
            input_declarations += "input         [15:0] block_ptr;\n"
            registers += "reg [7:0] block_base = 16'h0000;\nwire         [ADDR_MSB:0] block_src_addr = block_base+block_ptr+1;\nwire         [ADDR_MSB:0] block_dest_addr = block_base+block_ptr+2;\n"
            assigns += "assign block_id = blockmem[block_base][15:8];\nassign block_len = blockmem[block_base][7:0];\nassign block_entry_src = blockmem[block_src_addr];\nassign block_entry_dest = blockmem[block_dest_addr];\n"

        else:
            outputs += f"block_entry_src{i},\n\tblock_entry_dest{i},\n\tblock_len{i},\n\tblock_id{i},\n\t"
            inputs += f"block_ptr{i},\n\t"
            output_declarations += f"output [15:0] block_entry_src{i};\noutput [15:0] block_entry_dest{i};\noutput [7:0] block_len{i};\noutput [7:0] block_id{i};\n"
            input_declarations += f"input         [15:0] block_ptr{i};\n"
            registers += f"reg [15:0] block_base{i} = 16'h0000;\nwire         [ADDR_MSB:0] block_src_addr{i} = block_base{i}+block_ptr{i}+1;\nwire         [ADDR_MSB:0] block_dest_addr{i} = block_base{i}+block_ptr{i}+2;\n"
            assigns += f"assign block_id{i} = blockmem[block_base{i}][15:8];\nassign block_len{i} = blockmem[block_base{i}][7:0];\nassign block_entry_src{i} = blockmem[block_src_addr{i}];\nassign block_entry_dest{i} = blockmem[block_dest_addr{i}];\n"
            bases += "always @(posedge ram_clk)\nbegin\n\tblock_base2 <= 16'h1 + (block_len << 1);\n\t" if i == 2 else f"block_base{i} <= block_base{i-1} + 16'h1 + (block_len{i-1} << 1);\n\t"
    
    # Final string cleanup
    if bases != "":
        bases = bases[:-1] + "end\n"

    # Open template, repleace placeholders, write back out
    block_template = ""
    with open("templates/blockmem.v") as block_file:
        block_template = block_file.read()
    block_template = block_template.replace("OUTS", outputs)
    block_template = block_template.replace("INS", inputs)
    block_template = block_template.replace("DEC_O", output_declarations)
    block_template = block_template.replace("DEC_I", input_declarations)
    block_template = block_template.replace("REGS", registers)
    block_template = block_template.replace("ASSIGNS", assigns)
    block_template = block_template.replace("BASES", bases)
    with open("../spec-cfa/blockmem.v", "w") as block_file:
        block_file.write(block_template)


def build_fpga(paths):
    """
    Builds the openMSP430_fpga.v file for the selected paths
    Args:
        paths (int): The number of selected paths
    Returns:
        None
    """
    outputs_msp = ""
    inputs_msp = ""
    outputs_meta = ""
    inputs_meta = ""
    wires = ""

    for i in range(1, paths+1):
        if i == 1:
            outputs_msp += ".block_ptr         (block_ptr),\n\t"
            inputs_msp += ".block_entry_src        (block_entry_src),\n\t.block_entry_dest       (block_entry_dest),\n\t.block_len              (block_len),\n\t.block_id               (block_id),\n\t"
            inputs_meta += ".block_ptr         (block_ptr),\n\t"
            outputs_meta += ".block_entry_src        (block_entry_src),\n\t.block_entry_dest       (block_entry_dest),\n\t.block_len              (block_len),\n\t.block_id               (block_id),\n\t"
            wires += "wire [15:0] block_ptr;\nwire [15:0] block_entry_src;\nwire [15:0] block_entry_dest;\nwire  [7:0] block_len;\nwire  [7:0] block_id;\n"
        else:
            outputs_msp += f".block_ptr{i}         (block_ptr{i}),\n\t"
            inputs_msp += f".block_entry_src{i}        (block_entry_src{i}),\n\t.block_entry_dest{i}       (block_entry_dest{i}),\n\t.block_len{i}              (block_len{i}),\n\t.block_id{i}               (block_id{i}),\n\t"
            inputs_meta += f".block_ptr{i}         (block_ptr{i}),\n\t"
            outputs_meta += f".block_entry_src{i}        (block_entry_src{i}),\n\t.block_entry_dest{i}       (block_entry_dest{i}),\n\t.block_len{i}              (block_len{i}),\n\t.block_id{i}               (block_id{i}),\n\t"
            wires += f"wire [15:0] block_ptr{i};\nwire [15:0] block_entry_src{i};\nwire [15:0] block_entry_dest{i};\nwire  [7:0] block_len{i};\nwire  [7:0] block_id{i};\n"

    fpga_template = ""
    with open("templates/openMSP430_fpga.v") as fpga_file:
        fpga_template = fpga_file.read()
    fpga_template = fpga_template.replace("OUTS_MSP", outputs_msp)
    fpga_template = fpga_template.replace("OUTS_META", outputs_meta)
    fpga_template = fpga_template.replace("INS_MSP", inputs_msp)
    fpga_template = fpga_template.replace("INS_META", inputs_meta)
    fpga_template = fpga_template.replace("W_INIT", wires)
    with open("../openmsp430/fpga/openMSP430_fpga.v", "w") as fpga_file:
        fpga_file.write(fpga_template)


def build_meta(subpaths, paths):
    """
    Builds the speccfa_metadata.v file for the selected paths
    Args:
        subpaths (list(str)): The list of selected subpaths
        paths (int): The number of selected paths
    Returns:
        None
    """
    outputs = ""
    inputs = ""
    output_declarations = ""
    input_declarations = ""
    outputs_blockmem = ""
    inputs_blockmem = ""
    size = 0

    for i in range(1, paths+1):
        size += 2 + (4*len(subpaths[i-1]))
        if i == 1:
            outputs += "block_entry_src,\n\tblock_entry_dest,\n\tblock_len,\n\tblock_id,\n\t"
            inputs += "block_ptr,\n\t"
            output_declarations += "output [15:0] block_entry_src;\noutput [15:0] block_entry_dest;\noutput [7:0] block_len;\noutput [7:0] block_id;\n"
            input_declarations += "input         [15:0] block_ptr;\n"
            outputs_blockmem += ".block_entry_src      (block_entry_src),\n\t.block_entry_dest     (block_entry_dest),\n\t.block_len            (block_len),\n\t.block_id             (block_id),\n\t"
            inputs_blockmem += ".block_ptr          (block_ptr),\n\t"

        else:
            outputs += f"block_entry_src{i},\n\tblock_entry_dest{i},\n\tblock_len{i},\n\tblock_id{i},\n\t"
            inputs += f"block_ptr{i},\n\t"
            output_declarations += f"output [15:0] block_entry_src{i};\noutput [15:0] block_entry_dest{i};\noutput [7:0] block_len{i};\noutput [7:0] block_id{i};\n"
            input_declarations += f"input         [15:0] block_ptr{i};\n"
            outputs_blockmem += f".block_entry_src{i}      (block_entry_src{i}),\n\t.block_entry_dest{i}     (block_entry_dest{i}),\n\t.block_len{i}            (block_len{i}),\n\t.block_id{i}             (block_id{i}),\n\t"
            inputs_blockmem += f".block_ptr{i}          (block_ptr{i}),\n\t"
    
    try:
        sig_bit = math.floor(math.log2(size))
    except:
        sig_bit = 1
    log_size = 2**(sig_bit+1)
    meta_template = ""
    with open("templates/speccfa_metadata.v") as meta_file:
        meta_template = meta_file.read()
    meta_template = meta_template.replace("LOG_S", str(max(128, log_size)))
    meta_template = meta_template.replace("LOG_B", str(max(6,  sig_bit)))
    meta_template = meta_template.replace("OUTS", outputs)
    meta_template = meta_template.replace("INS", inputs)
    meta_template = meta_template.replace("DEC_O", output_declarations)
    meta_template = meta_template.replace("DEC_I", input_declarations)
    meta_template = meta_template.replace("BLOCKMEM_O", outputs_blockmem)
    meta_template = meta_template.replace("BLOCKMEM_I", inputs_blockmem)
    with open("../spec-cfa/speccfa_metadata.v", "w") as meta_file:
        meta_file.write(meta_template)


def build_msp(paths):
    """
    Builds the openMSP430.v file for the selected paths
    Args:
        paths (int): The number of selected paths
    Returns:
        None
    """
    outputs = ""
    inputs = ""
    output_declarations = ""
    input_declarations = ""
    inputs_spec = ""
    outputs_spec = ""

    for i in range(1, paths+1):
        if i == 1:
            inputs += "block_entry_src,\n\tblock_entry_dest,\n\tblock_len,\n\tblock_id,\n\t"
            outputs += "block_ptr,\n\t"
            input_declarations += "input [15:0] block_entry_src;\ninput [15:0] block_entry_dest;\ninput [7:0] block_len;\ninput [7:0] block_id;\n"
            output_declarations += "output         [15:0] block_ptr;\n"
            inputs_spec += ".block_entry_src      (block_entry_src),\n\t.block_entry_dest     (block_entry_dest),\n\t.block_len            (block_len),\n\t.block_id             (block_id),\n\t"
            outputs_spec += ".block_ptr          (block_ptr),\n\t"

        else:
            inputs += f"block_entry_src{i},\n\tblock_entry_dest{i},\n\tblock_len{i},\n\tblock_id{i},\n\t"
            outputs += f"block_ptr{i},\n\t"
            input_declarations += f"input [15:0] block_entry_src{i};\ninput [15:0] block_entry_dest{i};\ninput [7:0] block_len{i};\ninput [7:0] block_id{i};\n"
            output_declarations += f"output         [15:0] block_ptr{i};\n"
            inputs_spec += f".block_entry_src{i}      (block_entry_src{i}),\n\t.block_entry_dest{i}     (block_entry_dest{i}),\n\t.block_len{i}            (block_len{i}),\n\t.block_id{i}             (block_id{i}),\n\t"
            outputs_spec += f".block_ptr{i}          (block_ptr{i}),\n\t"

    msp_template = ""
    with open("templates/openMSP430.v") as msp_file:
        msp_template = msp_file.read()
    msp_template = msp_template.replace("OUTS", outputs)
    msp_template = msp_template.replace("I_N_S", inputs)
    msp_template = msp_template.replace("DEC_O", output_declarations)
    msp_template = msp_template.replace("DEC_I", input_declarations)
    msp_template = msp_template.replace("SPEC_I", inputs_spec)
    msp_template = msp_template.replace("SPEC_O", outputs_spec)
    with open("../openmsp430/msp_core/openMSP430.v", "w") as msp_file:
        msp_file.write(msp_template)


def build_spec(paths):
    """
    Builds the speccfa.v file for the selected paths
    Args:
        subpaths (list(str)): The list of selected subpaths
        paths (int): The number of selected paths
    Returns:
        None
    """
    outputs = ""
    inputs = ""
    output_declarations = ""
    input_declarations = ""
    detect = ""
    blocks = ""
    assigns = ""
    addr = ""
    id = ""

    for i in range(1, paths+1):
        if i == 1:
            inputs += "block_entry_src,\n\tblock_entry_dest,\n\tblock_len,\n\tblock_id,\n\t"
            outputs += "block_ptr,\n\t"
            input_declarations += "input [15:0] block_entry_src;\ninput [15:0] block_entry_dest;\ninput [7:0] block_len;\ninput [7:0] block_id;\n"
            output_declarations += "output         [15:0] block_ptr;\n"
            detect = "wire detect_mux = detect_active1 "
            blocks += "wire [15:0] block_ptr_out;\nwire detect_active1;\nwire [15:0] active_block_cflog_addr_out1;\nblock_detect block_detect_1(\n\t//inputs\n\t.clk                     (clk),\n\t.pc                      (pc),\n\n\t.cflow_hw_wen            (cflow_hw_wen),\n\t.cflow_log_ptr           (cflow_log_ptr),\n\t.cflow_src               (cflow_src),\n\t.cflow_dest              (cflow_dest),\n\n\t.block_entry_src         (block_entry_src),\n\t.block_entry_dest        (block_entry_dest),\n\t.block_len               (block_len),\n\t.block_id                (block_id),\n\t.cflog_bd_rd_src         (cflog_bd_rd_src),\n\t.cflog_bd_rd_dest        (cflog_bd_rd_dest),\n\n\t.detect_mux              (detect_mux),\n\n\t//outputs\n\t.block_ptr               (block_ptr_out),\n\t.bd_log_ptr              (bd_log_ptr),\n\t.detect_active           (detect_active1),\n\t.active_block_cflog_addr (active_block_cflog_addr_out1)\n\n);\n"
            assigns += "assign block_ptr  = (block_ptr_out  << 1); // 2*block_ptr_out;\n"
            addr += "wire [15:0] active_addr =   detect_active1 ? active_block_cflog_addr_out1 "
            id += "wire [7:0] active_id =    detect_active1 ? block_id "

        else:
            inputs += f"block_entry_src{i},\n\tblock_entry_dest{i},\n\tblock_len{i},\n\tblock_id{i},\n\t"
            outputs += f"block_ptr{i},\n\t"
            input_declarations += f"input [15:0] block_entry_src{i};\ninput [15:0] block_entry_dest{i};\ninput [7:0] block_len{i};\ninput [7:0] block_id{i};\n"
            output_declarations += f"output         [15:0] block_ptr{i};\n"
            detect += f"| detect_active{i} "
            blocks += f"wire [15:0] block_ptr_out{i};\nwire detect_active{i};\nwire [15:0] active_block_cflog_addr_out{i};\nblock_detect block_detect_{i}(\n\t//inputs\n\t.clk                     (clk),\n\t.pc                      (pc),\n\n\t.cflow_hw_wen            (cflow_hw_wen),\n\t.cflow_log_ptr           (cflow_log_ptr),\n\t.cflow_src               (cflow_src),\n\t.cflow_dest              (cflow_dest),\n\n\t.block_entry_src         (block_entry_src{i}),\n\t.block_entry_dest        (block_entry_dest{i}),\n\t.block_len               (block_len{i}),\n\t.block_id                (block_id{i}),\n\t.cflog_bd_rd_src         (cflog_bd_rd_src),\n\t.cflog_bd_rd_dest        (cflog_bd_rd_dest),\n\n\t.detect_mux              (detect_mux),\n\n\t//outputs\n\t.block_ptr               (block_ptr_out{i}),\n\t.bd_log_ptr              (bd_log_ptr),\n\t.detect_active           (detect_active{i}),\n\t.active_block_cflog_addr (active_block_cflog_addr_out{i})\n\n);\n"
            assigns += f"assign block_ptr{i}  = (block_ptr_out{i}  << 1); // 2*block_ptr_out{i};\n"
            addr += f":\n{28*' '}detect_active{i} ? active_block_cflog_addr_out{i} "
            id += f":\n{26*' '}detect_active{i} ? block_id{i} "
    
    if paths == 0:
        detect += "wire detect_mux = 0;\n"
        addr += "wire [15:0] active_addr = 16'b0;\n"
        id += " wire [7:0] active_id = 16'b0;\n"
    else:
        detect += ";\n"
        addr += ": 16'b0;\n"
        id += ": 16'b0;\n"

    spec_template = ""
    with open("templates/speccfa.v") as spec_file:
        spec_template = spec_file.read()
    spec_template = spec_template.replace("OUTS", outputs)
    spec_template = spec_template.replace("INS", inputs)
    spec_template = spec_template.replace("DEC_O", output_declarations)
    spec_template = spec_template.replace("DEC_I", input_declarations)
    spec_template = spec_template.replace("M_DET", detect)
    spec_template = spec_template.replace("ASSIGNS", assigns)
    spec_template = spec_template.replace("BLOCKS", blocks)
    spec_template = spec_template.replace("ADDR", addr)
    spec_template = spec_template.replace("ID", id)
    with open("../spec-cfa/speccfa.v", "w") as spec_file:
        spec_file.write(spec_template) 


def build_verilog_files(subpaths, paths):
    """
    Generates all the verilog files to support the number of subpaths selected
    Args:
        paths (int): The number of selected paths
    Returns:
        None
    """
    build_blockmem(paths)
    build_fpga(paths)
    build_meta(subpaths, paths)
    build_msp(paths)
    build_spec(paths) 

def build_boundry_monitor(hex):
    """
    Builds the boundary_monitor.v file to the desired cflog size
    Args:
        hex (str): The number of 2-byte addresses in the log in hex
    Returns:
        None
    """
    boundary_template = ""
    with open("templates/boundary_monitor.v") as boundary_file:
        boundary_template = boundary_file.read()
    boundary_template = boundary_template.replace("HEX", hex)
    with open("../acfa_hw/cfa_module/boundary_monitor.v", "w") as boundary_file:
        boundary_file.write(boundary_template) 

def build_cflogmem(hex, bits):
    """
    Builds the cflogmem.v file to the desired cflog size
    Args:
        hex (str): The number of 2-byte addresses in the log in hex
        bits (float): The most significant bit in the cflog size
    Returns:
        None
    """
    cflogmem_template = ""
    with open("templates/cflogmem.v") as cflogmem_file:
        cflogmem_template = cflogmem_file.read()
    cflogmem_template = cflogmem_template.replace("HEX", hex)
    cflogmem_template = cflogmem_template.replace("BITS", str(bits))
    with open("../acfa_hw/cfa_module/cflogmem.v", "w") as cflogmem_file:
        cflogmem_file.write(cflogmem_template) 

def build_cflow(hex):
    """
    Builds the cflow.v file to the desired cflog size
    Args:
        hex (str): The number of 2-byte addresses in the log in hex
    Returns:
        None
    """
    cflow_template = ""
    with open("templates/cflow.v") as cflow_file:
        cflow_template = cflow_file.read()
    cflow_template = cflow_template.replace("HEX", hex)
    with open("../acfa_hw/cfa_module/cflow.v", "w") as cflow_file:
        cflow_file.write(cflow_template) 

def build_cflog_files(size):
    """
    Generates all the verilog file associated with changing the size of cflog
    Args:
        size (int): The size of each cflog slice in bytes
    Returns:
        None
    """
    two_byte_size = int(size/2)
    hex_size = hex(two_byte_size)[2:]
    sig_bits = int(math.log2(two_byte_size))
    build_boundry_monitor(hex_size)
    build_cflogmem(hex_size, sig_bits)
    build_cflow(hex_size)

def main():
    """
    It does the thing
    """
    args = parse_args()

    if args.type == "manual":
        subpaths = get_subpaths_manual(args.file)
    elif args.type == "log":
        subpaths = get_subpaths_log(args.file)
    elif args.type == "binary":
        print("Unimplemented")
        exit(-1)
    else:
        print("Invalid subpath file type")
        exit(-1)
    
    build_test_files(subpaths, args.app.upper(), args.size) 
    build_verilog_files(subpaths, len(subpaths))
    build_cflog_files(args.size)


if __name__ == "__main__":
    main()
